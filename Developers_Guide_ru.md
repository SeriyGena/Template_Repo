Единый гайд по лучшим практикам разработки
1. Концепция проекта: "Симулятор данных"
Представим твой виртуальный проект как симулятор, который генерирует и анализирует данные, а затем отображает их в веб-интерфейсе для каждого пользователя. Проект состоит из нескольких модулей:

Модуль 1: Генератор данных: создает реалистичные наборы данных на основе заданных параметров.

Модуль 2: Аналитика: обрабатывает сгенерированные данные, проводит расчеты.

Модуль 3: Хранилище: управляет файлами и данными, привязанными к пользователю.

Модуль 4: Веб-сервис: предоставляет API для фронтенда и отображает результаты.

2. Организация папок и файлов
Твоя структура проекта уже идеальна для этого. Вот как она будет использоваться:

src/: Здесь будет находиться весь основной код.

src/data_generator/: Пакет для Модуля 1. Внутри будут файлы типа generator.py и parameters.py.

src/analytics/: Пакет для Модуля 2. Внутри — calculator.py и analyzer.py.

src/storage/: Пакет для Модуля 3. Здесь будут классы для работы с файлами, например, user_data_manager.py.

src/web_service/: Пакет для Модуля 4. Файл api.py или app.py для создания веб-приложения (на FastAPI или Flask).

src/__init__.py: Будет использоваться для управления публичным API. Например, чтобы импортировать src.web_service.app напрямую.

main.py: Точка входа в проект. Он будет запускать веб-сервис. Его код будет выглядеть примерно так:

Python

# main.py
import uvicorn
from src.web_service.app import create_app

app = create_app()

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
Как видишь, он оркестрирует, а не вычисляет. Вся логика находится в src.

test/: Для всех тестов. Структура будет зеркальной:

test/data_generator/test_generator.py

test/analytics/test_calculator.py

test/storage/test_user_data_manager.py

notebooks/: Для экспериментов. Ты можешь создать здесь файл prototype.ipynb для проверки формул в модуле аналитики, прежде чем переносить их в src/analytics/calculator.py.

data/: Входные и выходные данные, которые не являются частью кода. Например, здесь могут храниться файлы, сгенерированные симулятором, под именем пользователя (data/username/simulation_results.json).

3. Рабочий процесс: от идеи до продакшна
Твой чеклист "от прототипа до продакшна" — это и есть идеальный рабочий процесс. Вот как он будет выглядеть для твоего проекта:

Прототип (в notebooks/): У тебя появилась идея, как генерировать данные. Ты открываешь Jupyter notebook в папке notebooks/, пишешь код, экспериментируешь, строишь графики. Здесь Copilot будет твоим главным помощником — он поможет быстро сгенерировать функции для генерации данных.

Экстракция логики (в src/): Когда прототип работает, ты переносишь чистые функции и классы из ноутбука в src/data_generator/generator.py. Например, функция generate_user_data(). Добавляешь type hints и docstrings.

Создание тестов (в test/): Ты создаешь файл test/data_generator/test_generator.py. Используя pytest, ты пишешь тесты для твоей новой функции. Copilot может помочь сгенерировать шаблоны для тестов.

Финальное "продвижение": Ты убеждаешься, что тесты проходят. Запускаешь линтеры и форматтеры (black, flake8, mypy) для проверки качества кода. Теперь код готов к использованию другими частями приложения, например, веб-сервисом.

Интеграция: В файле src/web_service/app.py ты импортируешь generate_user_data и используешь ее, когда пользователь запрашивает симуляцию.

4. Роль Copilot в этом процессе
Прототипирование: Используй Copilot для быстрой генерации кода в Jupyter notebook.

Тестирование: Проси его генерировать тесты на основе твоих функций. Пример промпта: "Generate pytest tests for the generate_user_data function, covering a normal case and a case with invalid parameters".

Рефакторинг: Используй его для улучшения кода, например, "Refactor this function to be more concise and readable".


Этот документ описывает рекомендуемую архитектуру, рабочий процесс и использование GitHub Copilot для Python‑проекта с модульной структурой (симуляция данных → аналитика → хранение → веб‑API).

---
## 1. Концепция проекта: «Симулятор данных»
Проект состоит из четырёх логических модулей:

| Модуль | Роль | Примеры задач |
|--------|------|---------------|
| Генератор данных | Формирует синтетические наборы по параметрам пользователя | Псевдослучайные профили, временные ряды |
| Аналитика | Обрабатывает и агрегирует результаты | Метрики, статистика, преобразования |
| Хранилище | Управляет пользовательскими файлами и структурой каталогов | Чтение/запись, валидация путей |
| Веб‑сервис | Предоставляет API/HTTP интерфейс | REST/JSON ответы, эндпоинты запуска симуляции |

---
## 2. Организация папок и файлов

```text
src/
  data_generator/   # Модуль 1
  analytics/        # Модуль 2
  storage/          # Модуль 3
  web_service/      # Модуль 4 (FastAPI/Flask)
  __init__.py       # Экспорт публичного API
main.py             # Точка входа (минимальная оркестрация)
test/               # Зеркало структуры src/
notebooks/          # Прототипы и вычислительные эксперименты
data/               # Входные/выходные артефакты (НЕ код)
```

Назначение ключевых элементов:
- `src/__init__.py` — управляет тем, что считается публичным API.
- `main.py` — только запуск (парсинг аргументов, поднятие сервиса). Никакой бизнес‑логики.
- Подпакеты `data_generator`, `analytics`, `storage`, `web_service` — изолированные домены.
- `test/` — один файл тестов на один модуль / функциональный блок.
- `notebooks/` — временные прототипы. Код отсюда не импортируется напрямую в прод.

Пример минимального `main.py`:
```python
# main.py
import uvicorn
from src.web_service.app import create_app

app = create_app()

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---
## 3. Рабочий процесс (от идеи до продакшена)

| Этап | Где | Цель | Результат |
|------|-----|------|-----------|
| 1. Прототип | `notebooks/` | Проверить гипотезу | Рабочий эксперимент |
| 2. Экстракция | `src/...` | Перенос чистой логики | Функции/классы с типами |
| 3. Тесты | `test/...` | Зафиксировать поведение | pytest сценарии |
| 4. Стандарты | linters/formatters | Согласованность стиля | Пройденные black/flake8/mypy |
| 5. Интеграция | `web_service` | Использование API/сервисом | Эндпоинты вызывают доменные функции |
| 6. Рефакторинг | весь код | Устранение дублирования | Чище архитектура |
| 7. Коммит | git | История изменений | Маленький атомарный diff |

Подробно:
1. **Прототип**: Быстрые итерации. Разрешено «грязно», без тестов. Не переносить сырые фрагменты.
2. **Экстракция**: Переносим только чистые, детерминированные функции. Добавляем docstring + type hints.
3. **Тестирование**: Покрываем «норму», границы, ошибки. Используем `pytest.mark.parametrize`.
4. **Качество**: Запускаем: `black`, `isort`, `flake8`, `mypy`, `pytest`.
5. **Интеграция**: Добавляем слой адаптации (например, обработка запросов FastAPI → вызов функции домена → возврат схемы).
6. **Рефакторинг**: После зелёных тестов. Не меняем поведение без тестов.
7. **Коммит**: Сообщение формата `feat(generator): add time-series synthesis`.

---
## 4. Роль GitHub Copilot

| Сценарий | Как использовать | Пример запроса |
|----------|------------------|----------------|
| Генерация функции | Шаблон из `promts.md` | "Создай функцию генерации n записей с полями id, ts" |
| Создание тестов | После написания функции | "Generate pytest tests for generate_user_data (normal, invalid size)" |
| Рефакторинг | Когда есть дублирование | "Refactor to remove duplication and add input validation" |
| Обзор вариантов | Альтернативные реализации | "Suggest a more memory-efficient approach" |
| Прототипирование | Быстрые черновики в notebook | "Draft class skeleton for analytics pipeline" |

Принципы безопасного применения:
- Не принимать большие авто‑вставки без ревью.
- Всегда дописывать корректный docstring вручную.
- Проверять исключения и типы.

---
## 5. Стандарты кода

| Аспект | Правило |
|--------|--------|
| Именование функций | `snake_case`, префикс не обязателен если не оговорено |
| Исключения | Поднимать стандартные (`ValueError`, `TypeError`) или свои в `exceptions.py` |
| Типы | Все публичные функции типизированы |
| Докстринги | Формат Google / NumPy / PEP257 (единый стиль) |
| Логгирование | Только в слоях I/O и границах сервисов |
| Побочные эффекты | Защищены `if __name__ == "__main__":` |
| Импорты | Сначала стандартная библиотека, затем внешние, затем локальные |

Мини шаблон функции:
```python
def generate_user_data(count: int) -> list[dict]:
    """Генерирует тестовые пользовательские записи.

    Args:
        count: Количество записей (>0).
    Returns:
        Список словарей с полями id, timestamp.
    Raises:
        ValueError: Если count < 1.
    """
    if count < 1:
        raise ValueError("count must be >= 1")
    # ... реализация ...
    return []
```

---
## 6. Чеклисты

### Перед переносом из notebook → src
- [ ] Код чистый (без визуализаций)
- [ ] Функции детерминированны
- [ ] Нет захардкоженных путей
- [ ] Добавлены типы
- [ ] Есть минимальные тесты

### Перед коммитом
- [ ] `black .` прошёл
- [ ] `flake8` без ошибок
- [ ] `mypy` без новых предупреждений
- [ ] `pytest` зелёный
- [ ] Нет `print()` / TODO в прод‑коде

### Перед релевантной интеграцией в веб‑слой
- [ ] Обработаны ошибки (валидация входа)
- [ ] Нет прямого доступа к файловой системе из эндпоинта (через слой storage)
- [ ] Ответы сериализуемы (dict / pydantic модель)

---
## 7. Быстрые команды

```bash
# Локальная проверка качества
black . && isort . && flake8 && mypy src && pytest -q

# Запуск сервера (пример FastAPI)
uvicorn src.web_service.app:create_app --reload

# Генерация отчёта покрытия (при необходимости)
pytest --cov=src --cov-report=term-missing
```

---
## 8. Типичные ошибки и профилактика
| Ошибка | Как проявляется | Профилактика |
|--------|-----------------|--------------|
| Логика осталась в notebook | Функции нельзя переиспользовать | Немедленный перенос после стабилизации |
| Отсутствие тестов | Сломали при рефакторинге | Минимум: happy + edge + error |
| Грязный импорт уровня пакета | Побочные эффекты при импорте | Только определения в `__init__.py` |
| Отсутствие валидации входа | Тихие ошибки дальше по цепочке | Проверка и ранний raise |

---
## 9. Когда вводить усложнение архитектуры
| Сигнал | Действие |
|--------|----------|
| >3 мест дублирования | Выделить функцию / класс |
| Рост числа параметров (>5) | Ввести dataclass / pydantic модель |
| Смешение слоёв (I/O + расчёт) | Разделить на domain + adapters |
| Медленные тесты | Ввести разделение unit/integration |

---
## 10. Роль хранения данных
- В `storage/` держим адаптеры: файловая система, возможно в будущем БД.
- Чистая логика не должна знать о формате пути.
- Все пути через `pathlib.Path`.

---
## 11. Использование FastAPI (пример каркаса)
```python
# src/web_service/app.py
from fastapi import FastAPI
from src.data_generator.generator import generate_user_data

def create_app() -> FastAPI:
    app = FastAPI()

    @app.get("/simulate")
    def simulate(count: int = 10):
        return {"items": generate_user_data(count)}

    return app
```

---
## 12. Итог
Этот гайд служит «операционным стандартом»: каждый модуль изолирован, перенос — контролируемый, качество — измеримо, Copilot — ускоритель, а не автор архитектуры.

---
### Быстрый TL;DR
Прототип → Экстракция → Тесты → Качество → Интеграция → Рефакторинг → Коммит.

Работай малыми итерациями и держи доменную логику чистой.
